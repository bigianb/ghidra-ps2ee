############################
#
# MIPS32
# Basic and FP (COP1) instructions
############################

# 0000 00ss ssst tttt dddd d000 0010 0000
:add RD32, RS32src, RT32src           is prime=0 & sa=0 & fct=32 & RD32 & RS32src & RT32src & RD {
    RD32 = RS32src + RT32src;
    RD = sext(RD32);
}

# 0010 01ss ssst tttt iiii iiii iiii iiii
:addiu RT32, RS32src, simmed        is prime=9 & RT32 & RS32src & simmed & RT { 
    RT32 = RS32src + simmed;
    RT = sext(RT32);
}

# 0000 00ss ssst tttt dddd d000 0010 0001
:addu RD32, RS32src, RT32src          is prime=0 & fct=33 & RS32src & RT32src & RD32 & sa=0 & RD { 
    RD32 = RS32src + RT32src;
    RD = sext(RD32);
}

# 0000 00ss ssst tttt dddd d000 0010 0100
:and RD, RSsrc, RTsrc           is prime=0 & fct=36 & RSsrc & RTsrc & RD & sa=0 { 
    RD = RSsrc & RTsrc; 
}

# 0011 00ss ssst tttt iiii iiii iiii iiii
:andi RT, RSsrc, immed          is prime=12 & RSsrc & RT & immed { 
    RT = RSsrc & immed; 
}

# 0001 0000 0000 0000 iiii iiii iiii iiii 
:b Rel16                        is prime=4 & rs=0 & rt=0 & Rel16 { 
    delayslot(1); 
    goto Rel16; 
}

# 0001 00ss ssst tttt iiii iiii iiii iiii 
:beq RSsrc, RTsrc, Rel16        is prime=4 & RSsrc & RTsrc & Rel16 { 
    delayflag:1 = ( RSsrc == RTsrc ); 
    delayslot( 1 ); 
    if delayflag goto Rel16; 
}

# 0000 01ss sss0 0001 iiii iiii iiii iiii 
:bgez RSsrc, Rel16              is prime=1 & cond=1 & RSsrc & Rel16 {  
    delayflag:1 = ( RSsrc s>= 0 ); 
    delayslot( 1 ); 
    if delayflag goto Rel16; 
}
# 0001 11ss sss0 0000 iiii iiii iiii iiii 
:bgtz RSsrc, Rel16              is prime=7 & cond=0 & RSsrc & Rel16 {  
    delayflag:1 = ( RSsrc s> 0 ); 
    delayslot( 1 ); 
    if delayflag goto Rel16; 
} 
# 0001 10ss sss0 0000 iiii iiii iiii iiii 
:blez RSsrc, Rel16              is prime=6 & cond=0 & RSsrc & Rel16 { 
    delayflag:1 = ( RSsrc s<= 0 ); 
    delayslot( 1 ); 
    if delayflag goto Rel16; 
}

# 0000 01ss sss0 0000 iiii iiii iiii iiii 
:bltz RSsrc, Rel16              is prime=1 & cond=0 & RSsrc & Rel16 { 
    delayflag:1 = ( RSsrc s< 0 ); 
    delayslot( 1 ); 
    if delayflag goto Rel16; 
}
# 0001 01ss ssst tttt iiii iiii iiii iiii 
:bne RSsrc, RTsrc, Rel16        is prime=5 & RSsrc & RTsrc & Rel16 { 
    delayflag:1 = ( RSsrc != RTsrc ); 
    delayslot( 1 ); 
    if delayflag goto Rel16; 
}

# 0000 00cc cccc cccc cccc cccc cc00 1101
:break breakcode                is prime=0 & fct=13 & breakcode { 
    tmp:4=breakcode; 
    trap(tmp); 
}

# 1011 11bb bbbo oooo iiii iiii iiii iiii
:cache op, OFF_BASE           is ((prime=47 & REL6=0) | (prime=0x1E & REL6=1 & fct=0x25 & bit6=0)) & OFF_BASE & op {  
    cacheOp(op:1, OFF_BASE); 
}

:cachee op, OFF_BASE          is prime=0x1E & fct=0x1B & bit6=0 & OFF_BASE & op {
    cacheOp(op:1, OFF_BASE); 
}

:cfc0 RT, RD0                is prime=16 & copop=2 & RT & RD0 & bigfunct=0 {
    RT = sext( RD0:$(SIZETO4) );
}

# 0100 1000 010t tttt ssss s000 0000 0000
:cfc2 RT, immed                 is prime=18 & copop=2 & RT & immed {        
    tmp:4 = getCopControlWord( 2:1, immed:4 );
    RT = sext(tmp);
}

# Special case of ADDU
# 0000 0000 0000 0000 dddd d000 0010 0001
:clear RD                       is prime=0 & fct=33 & rs=0 & rt=0 & RD & sa=0    { 
    RD = 0; 
}

define pcodeop special2;

# 0111 00ss ssst tttt dddd daaa aaxx xyyy
# valid values of x and y:
# x: 0 y: 3,6,7
# x: 1 y: 0-7
# x: 2 y: 0-7
# x: 3 y: 0-7
# x: 4 y: 2,3,6,7
# x: 5 y: 0-7
# x: 6 y: 0-7
# x: 7 y: 0-6
:SPECIAL2 RD, RSsrc, RTsrc, sa, fct      is prime=0x1C & sa & RD & RSsrc & RTsrc & fct {
    tmp:1 = fct;
    tmp2:1 = sa;
    RD = special2(RSsrc, RTsrc, tmp2, tmp);
}

# 0100 101c cccc cccc cccc cccc cccc cccc
:cop2 cofun                     is prime=18 & bit25=1 & cofun {
    arg:4 = cofun;
    copFunction(2:1, arg);
}

:ctc0 RTsrc, RD0                is prime=16 & copop=6 & RTsrc & RD0 & bigfunct=0 {
    RD0 = RTsrc;
}
# 0100 1000 110t tttt iiii iiii iiii iiii
:ctc2 RTsrc, immed              is prime=18 & copop=6 & RTsrc & immed {
    setCopControlWord( 2:1, immed:4, RTsrc );
}

# 0100 0010 0000 0000 0000 0000 0001 1111 
:deret                          is prime=0x10 & bit25=1 & copfill=0x0 & fct=0x1F {
    return[DEPC];
}

# 0100 0001 011t tttt 0110 0000 0000 0000
:di                             is prime=0x10 & mfmc0=0x0B & rd=0x0C & fct2=0x0 & bit5=0x0 & zero3=0x0 & rt=0x0 {
    zero = Status;
    Status = Status & -2;   # clearing last bit (ffff..fffe == -2 signed)
}
:di RT                          is prime=0x10 & mfmc0=0x0B & rd=0x0C & fct2=0x0 & bit5=0x0 & zero3=0x0 & RT {
    RT = Status;
    Status = Status & -2;   # clearing last bit (ffff..fffe == -2 signed)
}

# 0000 0000 0000 0000 0000 0000 1100 0000
:ehb                            is prime=0x0 & rs=0x0 & rt=0x0 & rd=0x0 & fct2=0x3 & fct=0x0 {
} 

# 0100 0001 011t tttt 0110 0000 0010 0000
:ei                             is prime=0x10 & mfmc0=0x0B & rd=0x0C & fct2=0x0 & bit5=0x01 & zero3=0x0 & rt=0x0 {
    zero = Status;
    Status = Status | 1;
}
:ei RT                          is prime=0x10 & mfmc0=0x0B & rd=0x0C & fct2=0x0 & bit5=0x01 & zero3=0x0 & RT {
    RT = Status;
    Status = Status | 1;
}

# 0100 0010 0000 0000 0000 0000 0001 1000
:eret                           is prime=16 & fct=24 & bit25=1 & copfill=0  {
    return[EPC];
}

:eretnc							is prime=16 & fct=0x18 & bit25=1 & copfill=1  {
    return[EPC];
}

# 0111 11ss ssst tttt mmmm mLLL LL00 0000 
:ext RT, RSsrc, lsb, ExtSize    is prime=0x1F & fct=0x0 & RT & RSsrc & lsb & msbd & ExtSize {
    # Extract Bit Field
    # RT = extractField(RSsrc, msbd:1, lsb:1);
    # Note that msbd = size - 1
@if REGSIZE == "4"
    rs_tmp:4 = RSsrc << (32 - (msbd + lsb + 1));
    rs_tmp = rs_tmp >> (32 - (msbd + 1));
    RT = zext(rs_tmp);
@else
    rs_tmp:8 = RSsrc << (64 - (msbd + lsb + 1));
    rs_tmp = rs_tmp >> (64 - (msbd + 1));
    RT = zext(rs_tmp);
@endif
}

# 0111 11ss ssst tttt mmmm mLLL LL00 0100
:ins RT, RSsrc, lsb, InsSize    is prime=0x1F & fct=0x04 & RT & RTsrc & RSsrc & lsb & msbd & InsSize {
    tmpa:$(REGSIZE) = -1;
    tmpa = tmpa >> ($(REGSIZE) - InsSize);
    tmpb:$(REGSIZE) = RSsrc & tmpa;
    tmpa = tmpa << lsb;
    tmpa = ~tmpa;
    tmpb = tmpb << lsb;
    RT = (RT & tmpa) | tmpb;
}

# 0000 10aa aaaa aaaa aaaa aaaa aaaa aaaa
:j Abs26                        is prime=2 & Abs26 { 
    delayslot( 1 ); 
    goto Abs26; 
}
# 0000 11aa aaaa aaaa aaaa aaaa aaaa aaaa
:jal Abs26                      is prime=3 & Abs26 { 
    ra = inst_next; 
    delayslot( 1 ); 
    call Abs26; 
}

# 0000 00ss sss0 0000 dddd dhhh hh00 1001
:jalr RD, RSsrc                 is prime=0 & fct=9 & RSsrc & rt=0 & RD { 
    RD = inst_next;
    delayslot( 1 );
	tmp:$(ADDRSIZE) = 0;
	ValCast(tmp,RSsrc);
    call [tmp];     
}
:jalr RSsrc                     is prime=0 & fct=9 & RSsrc & rt=0 & rd=31 { 
    ra = inst_next; 
    delayslot( 1 ); 
	tmp:$(ADDRSIZE) = 0;
	ValCast(tmp,RSsrc);
    call [tmp];     
}

# 0000 00ss sss0 0000 dddd d1hh hh00 1001
:jalr.hb RD, RSsrc              is prime=0 & fct=9 & RSsrc & rt=0 & RD & bit10=1 { 
    RD = inst_next; 
    delayslot( 1 ); 
	tmp:$(ADDRSIZE) = 0;
	ValCast(tmp,RSsrc);
    call [tmp];     
}
:jalr.hb RSsrc                  is prime=0 & fct=9 & RSsrc & rt=0 & rd=31 & bit10=1 { 
    ra = inst_next; 
    delayslot( 1 ); 
	tmp:$(ADDRSIZE) = 0;
	ValCast(tmp,RSsrc);
    call [tmp];     
}



# 0000 00ss sss0 0000 0000 0hhh hh00 1000
:jr RSsrc                       is prime=0 & ((fct=8) | (REL6=1 & fct=0x09)) & RSsrc & rt=0 & rd=0 { 
    delayslot(1); 
 	tmp:$(ADDRSIZE) = 0;
	ValCast(tmp,RSsrc);
    goto [tmp]; 
}

# 0000 00ss sss0 0000 0000 01hh hh00 1000
:jr.hb RSsrc                    is prime=0 & ((fct=8) | (REL6=1 & fct=0x09)) & RSsrc & rt=0 & rd=0 & bit10=1 { 
    delayslot(1); 
 	tmp:$(ADDRSIZE) = 0;
	ValCast(tmp,RSsrc);
    goto [tmp]; 
}

# Special case of JR
# 0000 0011 1110 0000 0000 0hhh hh00 1000
:jr ra                           is prime=0 & ((fct=8) | (REL6=1 & fct=0x09)) & rs=31 & ra & rt=0 & rd=0 & sa=0    { 
    delayslot(1); 
    return[ra]; 
}

# 1000 00bb bbbt tttt iiii iiii iiii iiii
:lb RT, OFF_BASE                is prime=32 & OFF_BASE & RT {  
    RT = sext(*[ram]:1 OFF_BASE);  
}

# 1001 00bb bbbt tttt iiii iiii iiii iiii
:lbu RT, OFF_BASE               is prime=36 & OFF_BASE & RT {      
    RT = zext( *[ram]:1 OFF_BASE );
}

# 1000 01bb bbbt tttt iiii iiii iiii iiii
:lh RT, OFF_BASE                is prime=33 & OFF_BASE & RT { 
    RT = sext( *[ram]:2 OFF_BASE );
}

# 1001 01bb bbbt tttt iiii iiii iiii iiii
:lhu RT, OFF_BASE               is prime=37 & OFF_BASE & RT { 
    RT =  zext( *[ram]:2 OFF_BASE ); 
}

# 1000 11bb bbbt tttt iiii iiii iiii iiii
:lw RT, OFF_BASE                is prime=35 & OFF_BASE & RT {
    RT = sext( *[ram]:4 OFF_BASE );
}

# 0100 0000 000t tttt dddd d000 0000 0sss
:mfc0 RT, RD0                   is prime=16 & copop=0 & RT & RD0 & zero6=0 { 
    RT = sext( RD0:$(SIZETO4) );
}

# 0100 1000 000t tttt iiii iiii iiii iiii
:mfc2 RT, immed                 is prime=18 & copop=0 & RT & immed {
    tmp:$(REGSIZE) = getCopReg(2:1, immed:4);
    RT = sext( tmp );
}

# 0100 1000 011t tttt iiii iiii iiii iiii
:mfhc2 RT, immed                is prime=18 & copop=3 & RT & fs & immed {
    tmp:$(REGSIZE) = getCopReg(2:1, immed:4);
    RT = sext(tmp >> 32);
}

# Special case of ADDIU
# 0010 0100 000t tttt iiii iiii iiii iiii
:li RT, simmed                is prime=9 & rs=0 & RT & simmed            { 
    RT = simmed;
}
# Special case of ADDU
# 0000 0000 000t tttt dddd d000 0010 0001
:move RD, RTsrc                 is prime=0 & fct=33 & rs=0 & RD & RTsrc & sa=0    { 
    RD = RTsrc;
}
# Special case of ADDU
# 0000 00ss sss0 0000 dddd d000 0010 0001
:move RD, RSsrc                 is prime=0 & fct=33 & RSsrc & rt=0 & RD & sa=0    { 
    RD = RSsrc; 
}

# 0100 0000 100t tttt dddd d000 0000 0sss
:mtc0 RTsrc, RD0, sel               is prime=16 & copop=4 & RTsrc & RD0 & zero6=0 & sel { 
	setCopReg(0:1, RD0, RTsrc, sel:1); 
}
# 0100 1000 100t tttt iiii iiii iiii iiii
:mtc2 RTsrc, immed              is prime=18 & copop=4 & RTsrc & immed {
    setCopReg(2:1, immed:4, RTsrc);
}

:mthc0 RTsrc, RD0, sel          is prime=16 & copop=6 & RTsrc & RD0 & zero6=0 & sel {
	setCopReg(0:1, RD0, RTsrc, sel:1); 
}

# 0100 1000 111t tttt iiii iiii iiii iiii
:mthc2 RTsrc, immed             is prime=18 & copop=0x07 & RTsrc & immed {
    arg:4 = immed;
    tmp:4 = RTsrc:$(SIZETO4);
    low:4 = getCopReg(2:1, arg);
    val:8 = (zext(tmp) << 32) + zext(low);
    setCopReg(2:1, arg, val);
}

:nal             				is prime=1 & cond=0x10 & zero21=0 {
	delayslot(1);
	ra = inst_next;
} 

# 0000 0000 0000 0000 0000 0000 0000 0000 
:nop                            is prime=0 & rs=0 & rt=0 & rd=0 & sa=0 & fct=0  { 
}

# 0000 00ss ssst tttt dddd d000 0010 0111
:nor RD, RSsrc, RTsrc           is prime=0 & fct=39 & RSsrc & RTsrc & RD & sa=0 { 
    RD = ~(RSsrc | RTsrc); 
}
# 0000 00ss ssst tttt dddd d000 0010 0101
:or RD, RSsrc, RTsrc            is prime=0 & fct=37 & RSsrc & RTsrc & RD & sa=0 { 
    RD = RSsrc | RTsrc; 
}
# 0011 01ss ssst tttt iiii iiii iiii iiii
:ori RT, RSsrc, immed           is prime=13 & RSsrc & RT & immed  { 
    RT = RSsrc | immed; 
}

:pause							is prime=0 & szero=0 & fct=0 & fct2=0x05 {
	wait();
}

:pref hint, OFF_BASE            is prime=51 & hint & OFF_BASE {
    prefetch(OFF_BASE, hint:1); 
}   

# 0111 1100 000t tttt dddd d000 0011 1011
:rdhwr RT, RDsrc                is prime=31 & rs=0 & fct2=0 & fct=59 & RT & RDsrc {
    RT = getHWRegister(RDsrc);
}

# 0100 0001 010t tttt dddd d000 0000 0000 
:rdpgpr RD, RT                  is prime=16 & rs=10 & bigfunct=0 & RD & RT {
    RD = getShadow(RT);
}

# 0000 0000 001t tttt dddd daaa aa00 0010
:rotr RD32, RT32src, sa             is prime=0 & zero1=0 & bit21=1 & fct=2 & RD32 & RT32src & sa & RD {
    tmp1:4 = RT32src >> sa;
    tmp2:4 = RT32src << (32 - sa);
    RD32 = tmp1 + tmp2;
@ifdef MIPS64
    RD = sext(RD32);
@endif
}
# 0000 00ss ssst tttt dddd d000 0100 0110
:rotrv RD32, RT32src, RS32src         is prime=0 & zero2=0 & bit6=1 & fct=6 & RD32 & RT32src & RS32src & RD {
    shift:4 = RS32src & 0x1f;
    tmp1:4 = RT32src >> shift;
    tmp2:4 = RT32src << (32 - shift);
    RD32 = tmp1 + tmp2;
@ifdef MIPS64
    RD = sext(RD32);
@endif
}

# 1010 00bb bbbt tttt iiii iiii iiii iiii
:sb RTsrc, OFF_BASE             is prime=40 & OFF_BASE & RTsrc { 
    *[ram]:1 OFF_BASE = RTsrc:1;
}

# 0111 00cc cccc cccc cccc cccc cc11 1111
:sdbbp breakcode                is prime=28 & fct=63 & breakcode {
    signalDebugBreakpointException();
}

@ifndef COPR_C
# 1111 10bb bbbt tttt iiii iiii iiii iiii        
:sdc2 RTsrc, OFF_BASE           is prime=62 & OFF_BASE & RTsrc {  
    *[ram]:8 OFF_BASE = getCopReg(2:1, RTsrc);
}
@endif

# 0111 1100 000t tttt dddd d100 0010 0000
:seb RD, RTsrc                  is prime=31 & rs=0 & fct2=16 & fct=32 & RD & RTsrc {
    RD = sext( RTsrc:1 );
}
# 0111 1100 000t tttt dddd d110 0010 0000
:seh RD, RTsrc                  is prime=31 & rs=0 & fct2=24 & fct=32 & RD & RTsrc {
    RD = sext( RTsrc:2 );  
}
# 1010 01bb bbbt tttt iiii iiii iiii iiii
:sh RTsrc, OFF_BASE             is prime=41 & OFF_BASE & RTsrc { 
    *[ram]:2 OFF_BASE = RTsrc:2;  
}

# 0000 0000 000t tttt dddd daaa aa00 0000
:sll RD32, RT32src, sa              is prime=0 & fct=0 & rs=0 & RD32 & RT32src & sa & RD {    
    RD32 = RT32src << sa;
@ifdef MIPS64
    RD = sext(RD32);
@endif
}
# 0000 00ss ssst tttt dddd d000 0000 0100
:sllv RD32, RT32src, RS32src          is prime=0 & fct=4 & RS32src & RT32src & RD32 & sa=0 & RD { 
    shift:4 = RS32src & 0x1f;
    RD32 = RT32src << shift;
@ifdef MIPS64
    RD = sext(RD32);
@endif
}
# 0000 00ss ssst tttt dddd d000 0010 1010
:slt RD, RSsrc, RTsrc           is prime=0 & fct=42 & RSsrc & RTsrc & RD & sa=0 { 
    RD = zext( RSsrc s< RTsrc ); 
}
# 0010 10ss ssst tttt iiii iiii iiii iiii
:slti RT, RSsrc, simmed         is prime=10 & RSsrc & RT & simmed { 
    RT = zext( RSsrc s< simmed ); 
}
# 0010 11ss ssst tttt iiii iiii iiii iiii
:sltiu RT, RSsrc, simmed        is prime=11 & RSsrc & RT & simmed { 
    RT = zext( RSsrc < simmed ); 
}
# 0000 00ss ssst tttt dddd d000 0010 1011
:sltu RD, RSsrc, RTsrc          is prime=0 & fct=43 & RSsrc & RTsrc & RD & sa=0 { 
    RD = zext( RSsrc < RTsrc ); 
}

# 0000 0000 000t tttt dddd daaa aa00 0011
:sra RD32, RT32src, sa              is prime=0 & fct=3 & rs=0 & RT32src & RD32 & sa & RD { 
    RD32 = RT32src s>> sa;
@ifdef MIPS64
    RD = sext(RD32);
@endif
}
# 0000 00ss ssst tttt dddd d000 0000 0111
:srav RD32, RT32src, RS32src          is prime=0 & fct=7 & RS32src & RT32src & RD32 & sa=0 & RD { 
    shift:4 = RS32src & 0x1f;
    RD32 = RT32src s>> shift;
@ifdef MIPS64
    RD = sext(RD32);
@endif
}
# 0000 0000 000t tttt dddd daaa aa00 0010
:srl RD32, RT32src, sa              is prime=0 & fct=2 & rs=0 & RT32src & RD32 & sa & RD { 
    RD32 = RT32src >> sa; 
@ifdef MIPS64
    RD = sext(RD32);
@endif
}
# 0000 00ss ssst tttt dddd d000 0000 0110
:srlv RD32, RT32src, RS32src          is prime=0 & fct=6 & RS32src & RT32src & RD32 & sa=0 & RD { 
    shift:4 = RS32src & 0x1f;
    RD32 = RT32src >> shift; 
@ifdef MIPS64
    RD = sext(RD32);
@endif
}

# 0000 0000 0000 0000 0000 0000 0100 0000
:ssnop                          is prime=0 & rs=0 & rt=0 & rd=0 & sa=1 & fct=0 { 
}

# 0000 00ss ssst tttt dddd d000 0010 0010                           
:sub RD32, RS32src, RT32src           is prime=0 & fct=34 & RS32src & RT32src & RD32 & sa=0 & RD {    
    RD32 = RS32src - RT32src; 
@ifdef MIPS64
    RD = sext(RD32);
@endif
}
# 0000 00ss ssst tttt dddd d000 0010 0011
:subu RD32, RS32src, RT32src          is prime=0 & fct=35 & RS32src & RT32src & RD32 & sa=0 & RD { 
    RD32 = RS32src - RT32src;
@ifdef MIPS64
    RD = sext(RD32);
@endif
}

# 1010 11bb bbbt tttt iiii iiii iiii iiii
:sw RTsrc, OFF_BASE             is prime=43 & OFF_BASE & RTsrc {
    *[ram]:4 OFF_BASE = RTsrc:$(SIZETO4);    
}

@ifndef COPR_C
# 1110 10bb bbbt tttt iiii iiii iiii iiii
:swc2 hint, OFF_BASE              is prime=58 & OFF_BASE & hint { 
	tmp:4 = getCopReg(2:1, hint:4);
    *[ram]:4 OFF_BASE = tmp; 
}
@endif

define pcodeop SYNC;

# 0000 0000 0000 0000 0000 0yyy yy00 1111
:sync scalar                    is prime=0 & fct=15 & szero=0 & stype [ scalar = stype + 0; ] {
    SYNC(scalar:1);
}

# 0000 01bb bbb1 1111 iiii iiii iiii iiii
:synci OFF_BASE                 is prime=1 & OFF_BASE & synci=31  { 
}

# 0000 00cc cccc cccc cccc cccc cc00 1100
:syscall                        is prime=0 & fct=12 & breakcode { 
    tmp:4=breakcode; 
    syscall(tmp); 
}

# 0000 00ss ssst tttt cccc cccc cc11 0100
:teq RSsrc, RTsrc               is prime=0 & fct=52 & RSsrc & RTsrc & code { 
    if (RSsrc != RTsrc) goto <done>; 
    tmp:2=code; 
    trap(tmp);
    <done>
}
# 0000 00ss ssst tttt cccc cccc cc11 0000
:tge RSsrc, RTsrc               is prime=0 & fct=48 & RSsrc & RTsrc & code { 
    if (RSsrc < RTsrc) goto <done>; 
    tmp:2=code; 
    trap(tmp);
    <done>
}
# 0000 00ss ssst tttt cccc cccc cc11 0001
:tgeu RSsrc, RTsrc              is prime=0 & fct=49 & RSsrc & RTsrc & code { 
    if (RSsrc < RTsrc) goto <done>; 
    tmp:2=code; 
    trap(tmp);
    <done>
}

:tlbinv		is prime=0x10 & bit25=1 & copfill=0x00 & fct=0x03 {
    TLB_invalidate(Index, EntryHi);
}

:tlbinvf	is prime=0x10 & bit25=1 & copfill=0x00 & fct=0x04 {
    TLB_invalidate_flush(Index);
}

:tlbp		is prime=0x10  & bit25=1 & copfill=0x00 & fct=0x08 {
    Index = TLB_probe_for_matching_entry(EntryHi);
}

:tlbr           is prime=0x10  & bit25=1 & copfill=0x00 & fct=0x01 {
    EntryHi = TLB_read_indexed_entryHi(Index);
    EntryLo0 = TLB_read_indexed_entryLo0(Index);
    EntryLo1 = TLB_read_indexed_entryLo1(Index);
    PageMask = TLB_read_indexed_entryLo1(Index);
}

:tlbwi		is prime=0x10  & bit25=1 & copfill=0x00 & fct=0x02 {
    TLB_write_indexed_entry(Index, EntryHi, EntryLo0, EntryLo1, PageMask);
}

:tlbwr          is prime=0x10  & bit25=1 & copfill=0x00 & fct=0x06 {
    TLB_write_random_entry(Random, EntryHi, EntryLo0, EntryLo1, PageMask);
}

# 0000 00ss ssst tttt cccc cccc cc11 0010
:tlt RSsrc, RTsrc               is prime=0 & fct=50 & RSsrc & RTsrc & code { 
    if (RSsrc s>= RTsrc) goto <done>; 
    tmp:2=code; 
    trap(tmp);
    <done>
}
# 0000 00ss ssst tttt cccc cccc cc11 0011
:tltu RSsrc, RTsrc              is prime=0 & fct=51 & RSsrc & RTsrc & code { 
    if (RSsrc >= RTsrc) goto <done>; 
    tmp:2=code; 
    trap(tmp);
    <done>
}
# 0000 00ss ssst tttt cccc cccc cc11 0110
:tne RSsrc, RTsrc               is prime=0 & fct=54 & RSsrc & RTsrc & code { 
    if (RSsrc == RTsrc) goto <done>; 
    tmp:2=code; 
    trap(tmp);
    <done>
}

# 0100 001c cccc cccc cccc cccc cc10 0000
:wait                           is prime=16 & fct=32 & copfill & bit25=1  { 
    tmp:4 = copfill; 
    wait(tmp); 
}

# 0100 0001 110t tttt dddd d000 0000 0000
:wrpgpr  RD, RTsrc              is prime=16 & format=14 & RTsrc & RD & bigfunct=0  {
    setShadow(RD, RTsrc);
}

# 0111 1100 000t tttt dddd d000 1010 0000
:wsbh RD, RTsrc                 is prime=31 & format=0 & RTsrc & RD & wsbh=2 & bshfl=32 { 
    tmp1:$(REGSIZE) = RTsrc & 0xff; 
    tmp2:$(REGSIZE) = (RTsrc >> 8) & 0xff;
    tmp3:$(REGSIZE) = (RTsrc >> 16) & 0xff; 
    tmp4:$(REGSIZE) = (RTsrc >> 24) & 0xff;
    RD = (tmp3 << 24) | (tmp4 << 16) | (tmp1 << 8) | (tmp2); 
}

# 0000 00ss ssst tttt dddd d000 0010 0110
:xor RD, RSsrc, RTsrc           is prime=0 & fct=38 & RSsrc & RTsrc & RD & sa=0 { 
    RD = RSsrc ^ RTsrc; 
}
# 0011 10ss ssst tttt iiii iiii iiii iiii 
:xori RT, RSsrc, immed          is prime=14 & RSsrc & RT & immed { 
    RT = RSsrc ^ immed; 
}

############################
#
# MIPS64 Instructions to be included with all MIPS32 processors
#
############################

##  Allow MIPS 64 instructions below for compilers
##     using a 64-bit chip, but really keeping things to 32-bits

# Special case of daddu
# 0000 00ss ssst tttt dddd d000 0010 1101
:clear RD         is prime=0 & fct=45 & rs=0 & rt=0 & RD & sa=0 {
    RD = 0; 
}

# 0000 00ss ssst tttt dddd d000 0010 1100
:dadd RD, RSsrc, RTsrc          is prime=0 & fct=44 & RSsrc & RTsrc & RD & sa=0 {
    RD = RSsrc + RTsrc; 
}
# 0110 01ss ssst tttt iiii iiii iiii iiii
:daddiu RT, RSsrc, simmed       is prime=25 & RSsrc & RT & simmed {
    RT = RSsrc + simmed; 
}
# 0000 00ss ssst tttt dddd d000 0010 1101
:daddu RD, RSsrc, RTsrc         is prime=0 & fct=45 & RSsrc & RTsrc & RD & sa=0 {
    RD = RSsrc + RTsrc; 
}

# 0010 00ss ssst tttt iiii iiii iiii iiii
:addi RT32, RS32src, simmed         is prime=8 & RT32 & RS32src & simmed & RT { 
    RT32 = RS32src + simmed;
    RT = sext(RT32);
}

# 0000 01ss sss1 0001 iiii iiii iiii iiii
:bal Rel16            is prime=1 & cond=17 & rs=0 & Rel16 { 
    ra = inst_next; 
    delayslot( 1 ); 
    call Rel16; 
}

# Special case PIC
:bal Rel16            is prime=1 & cond=17 & rs=0 & off16=1 & Rel16 { 
    ra = inst_next; 
    delayslot( 1 ); 
    goto Rel16; 
}

# 0100 1001 000c cc00 iiii iiii iiii iiii
:bc2f Rel16                     is prime=18 & copop=8 & cc=0 & nd=0 & tf=0 & Rel16 { 
    tmp:1 = getCopCondition(2:1, 0:1); 
    delayslot(1); 
    if (tmp != 0) goto inst_next; 
    goto Rel16; 
}
:bc2f cc,Rel16                  is prime=18 & copop=8 & cc & nd=0 & tf=0 & Rel16 { 
    tmp:1 = getCopCondition(2:1, cc:1); 
    delayslot(1); 
    if (tmp != 0) goto inst_next; 
    goto Rel16; 
}
# 0100 1001 000c cc10 iiii iiii iiii iiii
:bc2fl Rel16                    is prime=18 & copop=8 & cc=0 & nd=1 & tf=0 & Rel16 { 
    tmp:1 = getCopCondition(2:1, 0:1); 
    if (tmp != 0) goto inst_next; 
    delayslot(1); 
    goto Rel16; 
}
:bc2fl cc,Rel16                 is prime=18 & copop=8 & cc & nd=1 & tf=0 & Rel16 { 
    tmp:1 = getCopCondition(2:1, cc:1); 
    if (tmp != 0) goto inst_next; 
    delayslot(1); 
    goto Rel16; 
}
# 0100 1001 000c cc01 iiii iiii iiii iiii
:bc2t Rel16                     is prime=18 & copop=8 & cc=0 & nd=0 & tf=1 & Rel16 { 
    tmp:1 = getCopCondition(2:1, 0:1); 
    delayslot(1); 
    if (tmp == 0) goto inst_next; 
    goto Rel16; 
}
:bc2t cc,Rel16                  is prime=18 & copop=8 & cc & nd=0 & tf=1 & Rel16 { 
    tmp:1 = getCopCondition(2:1, cc:1); 
    delayslot(1); 
    if (tmp == 0) goto inst_next; 
    goto Rel16; 
}
# 0100 1001 000c cc11 iiii iiii iiii iiii
:bc2tl Rel16                    is prime=18 & copop=8 & cc=0 & nd=1 & tf=1 & Rel16 { 
    tmp:1 = getCopCondition(2:1, 0:1); 
    if (tmp == 0) goto inst_next; 
    delayslot(1); 
    goto Rel16; 
}
:bc2tl cc,Rel16                 is prime=18 & copop=8 & cc & nd=1 & tf=1 & Rel16 { 
    tmp:1 = getCopCondition(2:1, cc:1); 
    if (tmp == 0) goto inst_next; 
    delayslot(1); 
    goto Rel16; 
}

# 0101 00ss ssst tttt iiii iiii iiii iiii
:beql RSsrc, RTsrc, Rel16       is prime=20 & RSsrc & RTsrc & Rel16 { 
    if (!(RSsrc==RTsrc)) goto inst_next; 
    delayslot(1); 
    goto Rel16; 
}

:bgezal RSsrc, Rel16            is prime=1 & cond=17 & RSsrc & Rel16 { 
    ra = inst_next; 
    delayflag:1 = ( RSsrc s>= 0 ); 
    delayslot( 1 ); 
    if (!delayflag) goto inst_next; 
    call Rel16; 
}

# 0000 01ss sss1 0011 iiii iiii iiii iiii
:bgezall RSsrc, Rel16           is prime=1 & cond=19 & RSsrc & Rel16 { 
    ra = inst_next; 
    if (!(RSsrc s>= 0)) goto inst_next; 
    delayslot( 1 ); 
    call Rel16; 
}
# 0000 01ss sss0 0011 iiii iiii iiii iiii 
:bgezl RSsrc, Rel16             is prime=1 & cond=3 & RSsrc & Rel16 { 
    if (!(RSsrc s>= 0)) goto inst_next; 
    delayslot(1); 
    goto Rel16; 
}
# 0101 11ss sss0 0000 iiii iiii iiii iiii 
:bgtzl RSsrc, Rel16             is prime=23 & cond=0 & RSsrc & Rel16 { 
    if (!(RSsrc s> 0)) goto inst_next; 
    delayslot(1); 
    goto Rel16; 
}
# 0101 10ss sss0 0000 iiii iiii iiii iiii 
:blezl RSsrc, Rel16             is prime=22 & cond=0 & RSsrc & Rel16 { 
    if (!(RSsrc s<= 0)) goto inst_next; 
    delayslot(1); 
    goto Rel16; 
}
# 0000 01ss sss1 0000 iiii iiii iiii iiii
:bltzal RSsrc, Rel16            is prime=1 & cond=16 & RSsrc & Rel16 { 
    ra = inst_next; 
    delayflag:1 = ( RSsrc s< 0 ); 
    delayslot( 1 ); 
    if (!delayflag) goto inst_next; 
    call Rel16; 
}
# 0000 01ss sss1 0010 iiii iiii iiii iiii
:bltzall RSsrc, Rel16           is prime=1 & cond=18 & RSsrc & Rel16 { 
    ra = inst_next; 
    if (!(RSsrc s< 0)) goto inst_next; 
    delayslot(1); 
    call Rel16; 
}
# 0000 01ss sss0 0010 iiii iiii iiii iiii 
:bltzl RSsrc, Rel16             is prime=1 & cond=2 & RSsrc & Rel16 { 
    if (!(RSsrc s< 0)) goto inst_next; 
    delayslot(1);
    goto Rel16; 
}
# 0101 01ss ssst tttt iiii iiii iiii iiii 
:bnel RSsrc, RTsrc, Rel16       is prime=21 & RSsrc & RTsrc & Rel16 { 
    if (!(RSsrc!=RTsrc)) goto inst_next; 
    delayslot(1); 
    goto Rel16; 
}

# 0111 00ss ssst tttt dddd d000 0010 0001
:clo RD, RSsrc                  is prime=0x1C & sa=0x0 & fct=0x21 & RD & RSsrc {
    # Count leading ones in a word
    RD = countLeadingOnes( RSsrc );
}

# 0111 00ss ssst tttt dddd d000 0010 0000
:clz RD, RSsrc                  is prime=0x1C & sa=0x0 & fct=0x20 & RD & RSsrc {
    # Count leading zeros in a word
    RD = countLeadingZeros( RSsrc );
}

# 0000 00ss ssst tttt 0000 0000 0001 1010
:div RS32src, RT32src               is prime=0 & fct=26 & RS32src & RT32src & rd=0 & sa=0 {
    lo = sext(RS32src s/ RT32src); 
    hi = sext(RS32src s% RT32src); 
}
# 0000 00ss ssst tttt 0000 0000 0001 1011
:divu RS32src, RT32src              is prime=0 & fct=27 & RS32src & RT32src & rd=0 & sa=0 { 
    lo = sext(RS32src / RT32src); 
    hi = sext(RS32src % RT32src);   
}

@ifndef COPR_C
# 1101 10bb bbbt tttt iiii iiii iiii iiii
:ldc2 rt, OFF_BASE              is prime=54 & OFF_BASE & rt {
    setCopReg(2:1, rt, *[ram]:8 OFF_BASE);
}
@endif

# 1100 00bb bbbt tttt iiii iiii iiii iiii
:ll RT, OFF_BASE                is prime=48 & OFF_BASE & RT {
    RT = sext(*[ram]:4 OFF_BASE);
}

# 0011 1100 000t tttt iiii iiii iiii iiii
:lui RT, immed                  is prime=15 & rs=0 & RT & immed {
    tmp:4 = immed << 16;
    RT = sext(tmp); 
}

@ifndef COPR_C
# 1100 10bb bbbt tttt iiii iiii iiii iiii
:lwc2 rt, OFF_BASE              is prime=50 & OFF_BASE & rt {
    setCopReg( 2:1, rt, *[ram]:4 OFF_BASE );    
}
@endif


:lwl RT, OFF_BASE               is prime=34 & OFF_BASE & RT & RTsrc { 
    shft:$(ADDRSIZE) = OFF_BASE & 0x3; 
    addr:$(ADDRSIZE) = OFF_BASE - shft; 
    valOrig:4 = RTsrc:$(SIZETO4) & (0xffffffff >> ((shft+1)* 8));
    valLoad:4 = *(addr) << ((3-shft) * 8);     
    RT = sext( valLoad | valOrig );            
}

# 1001 10bb bbbt tttt iiii iiii iiii iiii
:lwr RT, OFF_BASE               is prime=38 & OFF_BASE & RT & RTsrc {
    shft:$(ADDRSIZE) = OFF_BASE & 0x3; 
    addr:$(ADDRSIZE) = OFF_BASE - shft; 
    valOrig:4 = RTsrc:$(SIZETO4) & (0xffffffff << ((4-shft)* 8));
    valLoad:4 = *(addr) >> (shft * 8);
    RT = sext( valOrig | valLoad );
}

# lwl and lwr almost always come in pairs. 
# When the analyzer does finds a matching lwl/lwr pair, the pcode is simplified so that 
# lwl does all the loading while lwr is a no-op

:lwl RT, OFF_BASE               is prime=34 & OFF_BASE & RT & PAIR_INSTRUCTION_FLAG=1 [ PAIR_INSTRUCTION_FLAG = 1; globalset(inst_next, PAIR_INSTRUCTION_FLAG);] { 
}
:lwr RT, OFF_BASE               is prime=38 & OFF_BASE & RT & PAIR_INSTRUCTION_FLAG=1 [ PAIR_INSTRUCTION_FLAG = 0; ] {
    RT = sext( *[ram]:4 OFF_BASE );    
}

# 0111 00ss ssst tttt 0000 0000 0000 0000
:madd RS32src, RT32src              is prime=0x1C & zero4=0x0 & fct2=0x0 & fct=0x0 & RS32src & RT32src {
	tmp1:8 = sext(RS32src);
	tmp2:8 = sext(RT32src);
	prod:8 = tmp1 * tmp2;
        lo = lo & 0xffffffff;       # Make sure any upper bits of lo don't contribute to sum
	sum:8 = (zext(hi) << 32) + zext(lo) + prod;
    lo = sext(sum:4);    
    sum = sum >> 32;
    hi = sext(sum:4);    
}

# 0111 00ss ssst tttt 0000 0000 0000 0001
:maddu RS32src, RT32src             is prime=0x1C & zero4=0x0 & fct2=0x0 & fct=0x01 & RS32src & RT32src {
	tmp1:8 = zext(RS32src);
	tmp2:8 = zext(RT32src);
	prod:8 = tmp1 * tmp2;
        lo = lo & 0xffffffff;       # Make sure any upper bits of lo don't contribute to sum
	sum:8 = (zext(hi) << 32) + zext(lo) + prod;
    lo = sext(sum:4);
    sum = sum >> 32;
    hi = sext(sum:4); 
}

# 0000 0000 0000 0000 dddd d000 0001 0000
:mfhi RD                        is prime=0 & fct=16 & rs=0 & rt=0 & RD & sa=0 { 
    RD = hi; 
}
# 0000 0000 0000 0000 dddd d000 0001 0010
:mflo RD                        is prime=0 & fct=18 & rs=0 & rt=0 & RD & sa=0 { 
    RD = lo; 
}

# 0000 00ss ssst tttt dddd d000 0000 1011
:movn RD, RSsrc, RTsrc          is prime=0 & zero5=0 & fct=11 & RD & RSsrc & RTsrc  {
    if (RTsrc == 0) goto <done>; 
      RD = RSsrc;
    <done>
}
# 0000 00ss ssst tttt dddd d000 0000 1010
:movz RD, RSsrc, RTsrc          is prime=0 & zero5=0 & fct=10 & RD & RSsrc & RTsrc {
     if (RTsrc != 0) goto <done>; # We can't use goto inst_next because it fails if we are in a delay slot
       RD = RSsrc;
     <done>
}

# 0111 00ss ssst tttt 0000 0000 0000 0100
:msub RS32src, RT32src              is prime=0x1C & rd=0x0 & sa=0x0 & fct=0x04 & RS32src & RT32src {
	tmp1:8 = sext(RS32src);
	tmp2:8 = sext(RT32src);
	prod:8 = tmp1 * tmp2;
        lo = lo & 0xffffffff;       # Make sure any upper bits of lo don't contribute to sum
       	sum:8 = (zext(hi) << 32) + zext(lo) - prod;
    lo = sext(sum:4);    
    sum = sum >> 32;
    hi = sext(sum:4);    
}
# 0111 00ss ssst tttt 0000 0000 0000 0101
:msubu RS32src, RT32src             is prime=0x1C & zero4=0x0 & fct2=0x0 & fct=0x05 & RS32src & RT32src {
	tmp1:8 = zext(RS32src);
	tmp2:8 = zext(RT32src);
	prod:8 = tmp1 * tmp2;
        lo = lo & 0xffffffff;       # Make sure any upper bits of lo don't contribute to sum
	sum:8 = (zext(hi) << 32) + zext(lo) - prod;
    lo = sext(sum:4);    
    sum = sum >> 32;
    hi = sext(sum:4);    
}

# 0000 00ss sss0 0000 0000 0000 0001 0001
:mthi RSsrc                     is prime=0 & fct=17 & RSsrc & rt=0 & rd=0 & sa=0 { 
    hi = RSsrc; 
}
# 0000 00ss sss0 0000 0000 0000 0001 0011
:mtlo RSsrc                     is prime=0 & fct=19 & RSsrc & rt=0 & rd=0 & sa=0 { 
    lo = RSsrc; 
}
# 0111 00ss ssst tttt dddd d000 0000 0010
:mul RD, RS32src, RT32src           is prime=0x1C & sa=0x0 & fct=0x02 & RD & RS32src & RT32src {
    tmp1:8 = sext( RS32src );
    tmp2:8 = sext( RT32src );
    prod:8 = tmp1 * tmp2;
    RD = sext( prod:4 );
}
# 0000 00ss ssst tttt 0000 0000 0001 1000
:mult RS32src, RT32src              is prime=0 & fct=24 & RS32src & RT32src & rd=0 & sa=0 {
    tmp1:8 = sext( RS32src );
    tmp2:8 = sext( RT32src );
    prod:8 = tmp1 * tmp2;
    lo = sext(prod:4);    
    prod = prod >> 32;
    hi = sext(prod:4);    
}
# 0000 00ss ssst tttt 0000 0000 0001 1001
:multu RS32src, RT32src             is prime=0 & fct=25 & RS32src & RT32src & rd=0 & sa=0 { 
    tmp1:8 = zext( RS32src );
    tmp2:8 = zext( RT32src );
    prod:8 = tmp1 * tmp2;
    lo = sext(prod:4);    
    prod = prod >> 32;
    hi = sext(prod:4); 
}

# 0100 0110 110t tttt ssss sddd dd10 1100
:pll.ps fd, fs, ft              is prime=17 & format=22 & fct=44 & ft & fs & fd      
    unimpl

# 0100 0110 110t tttt ssss sddd dd10 1101
:plu.ps fd, fs, ft              is prime=17 & format=22 & fct=45 & ft & fs & fd      
    unimpl 

#:prefx

# 0100 0110 110t tttt ssss sddd dd10 1110
:pul.ps fd, fs, ft              is prime=17 & format=22 & fct=46 & fd & fs & ft   
    unimpl
# 0100 0110 110t tttt ssss sddd dd10 1111
:puu.ps fd, fs, ft              is prime=17 & format=22 & fct=47 & fd & fs & ft   
    unimpl

# 1110 00bb bbbt tttt iiii iiii iiii iiii
:sc RTsrc, OFF_BASE             is prime=56 & OFF_BASE & RT & RTsrc {
    *[ram]:4 OFF_BASE = RTsrc:$(SIZETO4);
    RT = 1;
}


# 1010 10bb bbbt tttt iiii iiii iiii iiii
:swl RTsrc, OFF_BASE            is prime=42 & OFF_BASE & RTsrc {
    tmpRT:4 = RTsrc:$(SIZETO4);  
    shft:$(ADDRSIZE) = OFF_BASE & 0x3; 
    addr:$(ADDRSIZE) = OFF_BASE - shft; 
    valOrig:4 = *(addr) & (0xffffffff << ((shft+1) * 8));
    valStore:4 = tmpRT >> ((3-shft) * 8);
    *(addr) = valOrig | valStore; 
}
# 1011 10bb bbbt tttt iiii iiii iiii iiii
:swr RTsrc, OFF_BASE            is prime=46 & OFF_BASE & RTsrc {
    tmpRT:4 = RTsrc:$(SIZETO4);
    shft:$(ADDRSIZE) = OFF_BASE & 0x3;      
    addr:$(ADDRSIZE) = OFF_BASE - shft; 
    valOrig:4 = *(addr) & (0xffffffff >> ((4-shft) * 8));
    valStore:4 = tmpRT << (shft*8);
    *(addr) = valOrig | valStore;
}

# When the analyzer finds a matching swl/swr pair, the pcode is simplified so that 
# swl does all the storing while swr is a no-op

:swl RTsrc, OFF_BASE            is prime=42 & OFF_BASE & RTsrc & PAIR_INSTRUCTION_FLAG=1 [ PAIR_INSTRUCTION_FLAG = 1; globalset(inst_next, PAIR_INSTRUCTION_FLAG);] {
}
:swr RTsrc, OFF_BASE            is prime=46 & OFF_BASE & RTsrc & PAIR_INSTRUCTION_FLAG=1 [ PAIR_INSTRUCTION_FLAG = 0; ]{
    *[ram]:4 OFF_BASE = RTsrc:$(SIZETO4);
}

# 0000 01ss sss0 1100 iiii iiii iiii iiii
:teqi RSsrc, simmed             is prime=1 & cond=12 & RSsrc & simmed { 
    if (RSsrc != simmed) goto <done>; 
    trap();
    <done>
}
# 0000 01ss sss0 1000 iiii iiii iiii iiii
:tgei RSsrc, simmed             is prime=1 & cond=8 & RSsrc & simmed { 
    if (RSsrc s< simmed) goto <done>; 
    trap();
    <done>
}
# 0000 01ss sss0 1001 iiii iiii iiii iiii
:tgeiu RSsrc, simmed            is prime=1 & cond=9 & RSsrc & simmed { 
    if (RSsrc < simmed) goto <done>; 
    trap();
    <done> 
}
# 0000 01ss sss0 1010 iiii iiii iiii iiii
:tlti RSsrc, simmed             is prime=1 & cond=10 & RSsrc & simmed { 
    if (RSsrc s>= simmed) goto <done>; 
    trap();
    <done>
}
# 0000 01ss sss0 1011 iiii iiii iiii iiii
:tltiu RSsrc, simmed            is prime=1 & cond=11 & RSsrc & simmed { 
    if (RSsrc >= simmed) goto <done>; 
    trap();
    <done>
}
# 0000 01ss sss0 1110 iiii iiii iiii iiii
:tnei RSsrc, simmed             is prime=1 & cond=14 & RSsrc & simmed { 
    if (RSsrc == simmed) goto <done>; 
    trap();
    <done> 
}

############################
#
# MIPS64 Instructions to be included with all MIPS32 processors
#
############################

##  Allow MIPS 64 instructions below for compilers
##     using a 64-bit chip, but really keeping things to 32-bits
# 0110 00ss ssst tttt iiii iiii iiii iiii
:daddi RT, RSsrc, simmed        is prime=24 & RSsrc & RT & simmed {
    RT = RSsrc + simmed; 
}

